// (c) 2025 Beem Media. All rights reserved.

#include "SgImgLibEdit.h"
#include "ImageLib/bitmapex.h"
#include "SgLib/SgFuncs.h"

/***************************************************************************

	SgImgLibEdit - For editing an SgImgLib

***************************************************************************/

SgImgLibEdit::SgImgLibEdit()
	: SgImgLib()
{

}

SgImgLibEdit::SgImgLibEdit(sg_uint32 nMaxEntries)
	: SgImgLib()
{

}

SgImgLibEdit::~SgImgLibEdit()
{
	CloseMainBitmaps();
}

bool SgImgLibEdit::AddBitmap(LPSTR szFilename)
{
	if (m_SourceImageData.size() >= MAX_BITMAPS)
	{
		return false;
	}

	m_SourceImageData.resize(m_SourceImageData.size() + 1);
	OpenBitmap(szFilename, static_cast<sg_uint16>(m_SourceImageData.size()));

	OpenMainBitmaps();

	return true;
}

bool SgImgLibEdit::AddEntry(
	sg_uint16 x,
	sg_uint16 y,
	sg_uint16 nWidthSrc,
	sg_uint16 nHeightSrc,
	sg_uint16 nWidth,
	sg_uint16 nHeight,
	sg_uint16 nBitmap,
	sg_uint16 nFrames,
	LPSTR szImageName
) {
	m_ImageData.resize(m_ImageData.size() + 1);
	SetEntry(
		m_ImageData.size(),
		x,
		y,
		nWidthSrc,
		nHeightSrc,
		nWidth,
		nHeight,
		nBitmap,
		nFrames,
		szImageName);

	return true;
}

bool SgImgLibEdit::SetEntry(
	sg_uint32 nReference,
	sg_uint16 x,
	sg_uint16 y,
	sg_uint16 nWidthSrc,
	sg_uint16 nHeightSrc,
	sg_uint16 nWidth,
	sg_uint16 nHeight,
	sg_uint16 nBitmap,
	sg_uint16 nFrames,
	LPSTR szImageName
) {
	if ((nReference < 1) || (nReference > m_ImageData.size()))return false;

	m_ImageData[nReference - 1].nX = x;
	m_ImageData[nReference - 1].nY = y;
	m_ImageData[nReference - 1].nWidthSrc = nWidthSrc;
	m_ImageData[nReference - 1].nHeightSrc = nHeightSrc;
	m_ImageData[nReference - 1].nWidth = nWidth;
	m_ImageData[nReference - 1].nHeight = nHeight;
	m_ImageData[nReference - 1].nBitmap = nBitmap;
	m_ImageData[nReference - 1].nFrames = nFrames;

	//convert image name to wide char
	MultiByteToWideChar(
		CP_ACP,
		MB_PRECOMPOSED,
		szImageName,
		-1,
		m_ImageData[nReference - 1].szImgLabel,
		IMAGE_NAME_LENGTH);

	return true;
}

bool SgImgLibEdit::AutoGenerateData(
	sg_uint16 nBitmap,
	sg_uint16 nWidth,
	sg_uint16 nHeight,
	sg_uint16 nXSpacing,
	sg_uint16 nYSpacing,
	BOOL bClear
)
{
	//bail if main bitmap does not exist
	if ((nBitmap < 1) || (nBitmap > m_SourceImageData.size()))return false;
	if (!m_hBitmap[nBitmap - 1])return false;

	int nNumAcross = 0;
	int nNumDown = 0;
	int nNumTiles = 0;
	int nReference = 0;

	BITMAP bm;
	GetObject(m_hBitmap[nBitmap - 1], sizeof(bm), &bm);

	//get how many bitmaps across as well as how many down
	nNumAcross = bm.bmWidth / (nWidth + nXSpacing);
	nNumDown = bm.bmHeight / (nHeight + nYSpacing);
	nNumTiles = nNumAcross * nNumDown;
	if (bClear) {
		m_ImageData.resize(0);
	}
	nReference = m_ImageData.size() + 1;
	for (int down = 0; down < nNumDown; down++) {
		for (int across = 0; across < nNumAcross; across++, nReference++) {
			AddEntry(
				across * (nWidth + nXSpacing),
				down * (nHeight + nYSpacing),
				nWidth,
				nHeight,
				nWidth,
				nHeight,
				nBitmap,
				1,
				"");
		}
	}
	return true;
}


bool SgImgLibEdit::SaveData(LPSTR szFilename)
{
	//Declare headers
	IMGLIBHEADER lbHeader = { };
	IMGDBHEADER dbHeader = { };

	//fill in library header
	lbHeader.wType = IMGLIB_HEADER_ID;
	lbHeader.nVersion = IMGLIB_IDA_VERSION;
	lbHeader.lReserved1 = lbHeader.lReserved2 = 0;
	lbHeader.nOffsetBytes = sizeof(IMGLIBHEADER);

	//fill in database header
	dbHeader.nEntries = m_ImageData.size();
	dbHeader.nNumBMs = static_cast<sg_uint16>(m_SourceImageData.size());
	dbHeader.nSizeofEntryData = (m_ImageData.size() * sizeof(IMAGEDATA));

	//declare handle for file for writing
	HANDLE hFile = INVALID_HANDLE_VALUE;
	DWORD dwBytesWritten = 0;

	//open file for writing
	hFile = CreateFileA(
		szFilename,
		GENERIC_WRITE,
		FILE_SHARE_WRITE,
		(LPSECURITY_ATTRIBUTES)NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		(HANDLE)NULL);

	if (hFile == INVALID_HANDLE_VALUE)return false;

	//we start by writing the IMGLIBHEAER
	WriteFile(hFile, &lbHeader, sizeof(IMGLIBHEADER), &dwBytesWritten, NULL);
	//write the database header next
	WriteFile(hFile, &dbHeader, sizeof(IMGDBHEADER), &dwBytesWritten, NULL);

	//we now write the bitmap filenamedata
	for (std::size_t i = 0; i < m_SourceImageData.size(); i++)
	{
		const sg_uint16 nBMNameSize = static_cast<sg_uint16>(m_SourceImageData[i].Filename.length() + 1) * sizeof(wchar_t);

		//Write the size of the name
		WriteFile(hFile, &nBMNameSize, sizeof(sg_uint16), &dwBytesWritten, NULL);
		//write the actual name
		WriteFile(hFile, m_SourceImageData[i].Filename.c_str(), nBMNameSize, &dwBytesWritten, NULL);
	}

	//now write image data
	WriteFile(hFile, m_ImageData.data(), dbHeader.nSizeofEntryData, &dwBytesWritten, NULL);

	//we are now done, so close file
	CloseHandle(hFile);
	return true;
}


bool SgImgLibEdit::LoadData(LPSTR szFilename)
{
	//Declare headers
	IMGLIBHEADER lbHeader = { };
	IMGDBHEADER dbHeader = { };

	//declare file to read
	HANDLE hFile = INVALID_HANDLE_VALUE;

	//open file for reading
	hFile = CreateFileA(
		szFilename,
		GENERIC_READ,
		FILE_SHARE_READ,
		(LPSECURITY_ATTRIBUTES)NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		(HANDLE)NULL);

	DWORD dwBytesRead = 0;

	//begin by reading the header
	ReadFile(hFile, &lbHeader, sizeof(IMGLIBHEADER), &dwBytesRead, NULL);

	if (lbHeader.wType != IMGLIB_HEADER_ID) {
		CloseHandle(hFile);
		return false;
	}
	if (lbHeader.nVersion != IMGLIB_IDA_VERSION) {
		CloseHandle(hFile);
		return false;
	}
	//we now know that the file is the correct type so continue
	//read the database header
	ReadFile(hFile, &dbHeader, sizeof(IMGDBHEADER), &dwBytesRead, NULL);

	m_ImageData.resize(dbHeader.nEntries);
	m_SourceImageData.resize(dbHeader.nNumBMs);

	//we now read the bitmap filenames
	

	for (std::size_t i = 0; i < m_SourceImageData.size(); i++)
	{
		sg_uint16 nBMNameLen = 0;
		//get size of entry
		ReadFile(hFile, &nBMNameLen, sizeof(sg_uint16), &dwBytesRead, NULL);
		//read entry
		std::vector<wchar_t> TempStr;
		TempStr.resize(nBMNameLen / sizeof(wchar_t));
		ReadFile(hFile, TempStr.data(), nBMNameLen, &dwBytesRead, NULL);
		m_SourceImageData[i].Filename = TempStr.data();
	}
	//read image data
	ReadFile(hFile, m_ImageData.data(), dbHeader.nSizeofEntryData, &dwBytesRead, NULL);
	//were done now close the file
	CloseHandle(hFile);
	//now attempt to load bitmaps

	OpenMainBitmaps();

	return true;
}

bool SgImgLibEdit::BuildLibrary(LPSTR szFilename)
{
	IMGLIBHEADER lbHeader = { };
	IMGHEADER imHeader = { };

	//prepare the headers
	lbHeader.wType = IMGLIB_HEADER_ID;
	lbHeader.nVersion = 20;
	lbHeader.lReserved1 = 0;
	lbHeader.lReserved2 = 0;
	lbHeader.nOffsetBytes = sizeof(IMGLIBHEADER);

	imHeader.nEntrys = m_ImageData.size();
	imHeader.nNumBMs = static_cast<sg_uint16>(m_SourceImageData.size());
	imHeader.nSizeofEntryData = (m_ImageData.size() * sizeof(IMAGEDATA));
	imHeader.nSizeofBitmapInfo = (m_SourceImageData.size() * sizeof(BITMAPDATA));

	//get the size of all the bitmaps and read their data
	BITMAPDATA bmData[MAX_BITMAPS];
	ZeroMemory(&bmData, sizeof(BITMAPDATA) * MAX_BITMAPS);

	DWORD dwBytesRead = 0, dwBytesWritten = 0;

	std::size_t i = 0, j = 0;
	//sg_uint32 dwBitmapSize[MAX_BITMAPS];
	BYTE* btBitmapData[MAX_BITMAPS];
	HANDLE hFile = NULL;

	for (i = 0; i < m_SourceImageData.size(); i++) {
		hFile = CreateFileW(
			m_SourceImageData[i].Filename.c_str(),
			GENERIC_READ,
			FILE_SHARE_READ,
			(LPSECURITY_ATTRIBUTES)NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			(HANDLE)NULL);

		if (hFile == INVALID_HANDLE_VALUE) {
			for (j = 0; j < i; j++) {
				SAFE_DELETE_ARRAY(btBitmapData[i]);
			}

			CloseHandle(hFile);
			return false;
		}

		bmData[i].dwSize = GetFileSize(hFile, NULL);
		btBitmapData[i] = new BYTE[bmData[i].dwSize];

		if (btBitmapData[i] == NULL) {
			CloseHandle(hFile);
			for (j = 0; j < i; j++) {
				SAFE_DELETE_ARRAY(btBitmapData[i]);
			}
			return false;
		}
		if (!ReadFile(hFile, btBitmapData[i], bmData[i].dwSize, &dwBytesRead, NULL)) {
			CloseHandle(hFile);
			for (j = 0; j <= i; j++) {
				SAFE_DELETE_ARRAY(btBitmapData[i]);
			}
			return false;
		}
		CloseHandle(hFile);

	}
	//prepare bitmap offsets
	for (i = 0; i < m_SourceImageData.size(); i++) {
		bmData[i].dwOffset =
			sizeof(IMGLIBHEADER) +
			sizeof(IMGHEADER) +
			imHeader.nSizeofEntryData +
			imHeader.nSizeofBitmapInfo;
		for (j = 0; j < i; j++) {
			bmData[i].dwOffset += bmData[j].dwSize;
		}

	}
	//we've now read all the bitmaps let's begin writing the file
	hFile = CreateFileA(
		szFilename,
		GENERIC_WRITE,
		FILE_SHARE_WRITE,
		(LPSECURITY_ATTRIBUTES)NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		(HANDLE)NULL);

	//if failed to open file clear bitmap data and exit
	if (hFile == INVALID_HANDLE_VALUE) {
		CloseHandle(hFile);
		for (j = 0; j < m_SourceImageData.size(); j++) {
			SAFE_DELETE_ARRAY(btBitmapData[i]);
		}

		return false;
	}

	//write the headers
	WriteFile(hFile, &lbHeader, sizeof(IMGLIBHEADER), &dwBytesWritten, NULL);
	WriteFile(hFile, &imHeader, sizeof(IMGHEADER), &dwBytesWritten, NULL);
	//write bitmap info
	WriteFile(hFile, &bmData, imHeader.nSizeofBitmapInfo, &dwBytesWritten, NULL);
	//write image data
	WriteFile(hFile, m_ImageData.data(), imHeader.nSizeofEntryData, &dwBytesWritten, NULL);

	//write the bitmaps one by one
	for (i = 0; i < m_SourceImageData.size(); i++) {
		WriteFile(hFile, btBitmapData[i], bmData[i].dwSize, &dwBytesWritten, NULL);
	}

	//were done close file and delete image data
	CloseHandle(hFile);
	for (i = 0; i < m_SourceImageData.size(); i++) {
		SAFE_DELETE_ARRAY(btBitmapData[i]);
	}


	return true;
}


bool SgImgLibEdit::ImportLibrary(LPSTR szFilename)
{
	IMGLIBHEADER lbHeader;
	IMGHEADER imHeader;
	HANDLE hFile;
	BITMAPDATA bmData[MAX_BITMAPS];
	DWORD dwBytesRead = 0;

	ZeroMemory(&lbHeader, sizeof(IMGLIBHEADER));
	ZeroMemory(&imHeader, sizeof(IMGHEADER));

	hFile = CreateFileA(
		szFilename,
		GENERIC_READ,
		FILE_SHARE_READ,
		(LPSECURITY_ATTRIBUTES)NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		(HANDLE)NULL);

	if (hFile == INVALID_HANDLE_VALUE) {
		return false;
	}

	ReadFile(hFile, &lbHeader, sizeof(IMGLIBHEADER), &dwBytesRead, NULL);
	if (lbHeader.wType != IMGLIB_HEADER_ID) {
		CloseHandle(hFile);
		return false;
	}
	if (lbHeader.nVersion != IMGLIB_ILB_VERSION) {
		CloseHandle(hFile);
		return false;
	}

	//we know the file is correct so continue reading
	ClearDataBase();

	ReadFile(hFile, &imHeader, sizeof(IMGHEADER), &dwBytesRead, NULL);
	ReadFile(hFile, &bmData, imHeader.nSizeofBitmapInfo, &dwBytesRead, NULL);
	m_ImageData.resize(imHeader.nEntrys);
	ReadFile(hFile, m_ImageData.data(), imHeader.nSizeofEntryData, &dwBytesRead, NULL);

	CloseHandle(hFile);
	//at this point we've loaded all the data, but
	//we need to extract the bitmap files and load them
	//into the new file
	DWORD dwBytesWritten = 0;
	int i = 0;
	char szBitmapName[MAX_PATH];
	BYTE* pBitmap = NULL;

	for (i = 0; i < imHeader.nNumBMs; i++)
	{
		hFile = CreateFileA(
			szFilename,
			GENERIC_READ,
			FILE_SHARE_READ,
			(LPSECURITY_ATTRIBUTES)NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			(HANDLE)NULL);

		if (hFile == INVALID_HANDLE_VALUE)return false;

		pBitmap = new BYTE[bmData[i].dwSize];

		SetFilePointer(hFile, bmData[i].dwOffset, NULL, FILE_BEGIN);

		ReadFile(hFile, pBitmap, bmData[i].dwSize, &dwBytesRead, NULL);

		CloseHandle(hFile);

		sprintf_s(szBitmapName, countof(szBitmapName), "%s[%i].bmp", szFilename, i + 1);
		hFile = CreateFileA(
			szBitmapName,
			GENERIC_WRITE,
			FILE_SHARE_WRITE,
			(LPSECURITY_ATTRIBUTES)NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			hFile);

		if (hFile == INVALID_HANDLE_VALUE)return false;

		WriteFile(hFile, pBitmap, bmData[i].dwSize, &dwBytesWritten, NULL);

		SAFE_DELETE_ARRAY(pBitmap);

		CloseHandle(hFile);

		AddBitmap(szBitmapName);

	}
	return true;
}

void SgImgLibEdit::ClearDataBase()
{
	CloseMainBitmaps();

	m_ImageData.resize(0);
	m_SourceImageData.resize(0);
}

void SgImgLibEdit::CloseMainBitmaps()
{
	for (auto& Item : m_hBitmap)
	{
		if (Item)
		{
			DeleteObject(Item);
		}
		Item = NULL;
	}
}


void SgImgLibEdit::OpenMainBitmaps()
{
	CloseMainBitmaps();

	for (std::size_t i = 0; i < m_SourceImageData.size(); i++)
	{
		if (i < countof(m_hBitmap))
		{
			m_hBitmap[i] = LoadBitmapOffset(SgFunc_ToMBString(m_SourceImageData[i].Filename).c_str(), 0, 0);
		}
	}
}



void SgImgLibEdit::CopyImageToDC(HDC hdcDest, sg_uint32 nEntry, int x, int y, BOOL bTransp)
{
	HDC hdcMainBitmap = NULL;

	if ((nEntry < 1) || (nEntry > m_ImageData.size()))return;

	hdcMainBitmap = CreateCompatibleDC(hdcMainBitmap);
	SelectObject(hdcMainBitmap, m_hBitmap[m_ImageData[nEntry - 1].nBitmap - 1]);


	if (!bTransp) {
		StretchBlt(
			hdcDest,
			x,
			y,
			m_ImageData[nEntry - 1].nWidth,
			m_ImageData[nEntry - 1].nHeight,
			hdcMainBitmap,
			m_ImageData[nEntry - 1].nX,
			m_ImageData[nEntry - 1].nY,
			m_ImageData[nEntry - 1].nWidthSrc,
			m_ImageData[nEntry - 1].nHeightSrc,
			SRCCOPY);
	}
	else {
		TransparentBlt2(
			hdcDest,
			x,
			y,
			m_ImageData[nEntry - 1].nWidth,
			m_ImageData[nEntry - 1].nHeight,
			hdcMainBitmap,
			m_ImageData[nEntry - 1].nX,
			m_ImageData[nEntry - 1].nY,
			m_ImageData[nEntry - 1].nWidthSrc,
			m_ImageData[nEntry - 1].nHeightSrc,
			RGB(255, 0, 255));

	}

	DeleteDC(hdcMainBitmap);
}


void SgImgLibEdit::StretchImageToDC(HDC hdcDest, sg_uint32 nEntry, int x, int y, int nWidth, int nHeight, BOOL bTransp)
{
	HDC hdcMainBitmap = NULL;

	if ((nEntry < 1) || (nEntry > m_ImageData.size()))return;

	hdcMainBitmap = CreateCompatibleDC(hdcMainBitmap);
	SelectObject(hdcMainBitmap, m_hBitmap[m_ImageData[nEntry - 1].nBitmap - 1]);


	if (!bTransp) {
		StretchBlt(
			hdcDest,
			x,
			y,
			nWidth,
			nHeight,
			hdcMainBitmap,
			m_ImageData[nEntry - 1].nX,
			m_ImageData[nEntry - 1].nY,
			m_ImageData[nEntry - 1].nWidthSrc,
			m_ImageData[nEntry - 1].nHeightSrc,
			SRCCOPY);
	}
	else {
		TransparentBlt2(
			hdcDest,
			x,
			y,
			nWidth,
			nHeight,
			hdcMainBitmap,
			m_ImageData[nEntry - 1].nX,
			m_ImageData[nEntry - 1].nY,
			m_ImageData[nEntry - 1].nWidthSrc,
			m_ImageData[nEntry - 1].nHeightSrc,
			RGB(255, 0, 255));

	}

	DeleteDC(hdcMainBitmap);
}
